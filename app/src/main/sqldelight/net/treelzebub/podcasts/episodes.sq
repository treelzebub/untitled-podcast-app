import kotlin.Boolean;

CREATE TABLE episode (
    id TEXT PRIMARY KEY NOT NULL,
    channel_id TEXT NOT NULL,
    channel_title TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    date INTEGER NOT NULL,
    link TEXT NOT NULL,
    streaming_link TEXT NOT NULL,
    image_url TEXT,
    duration TEXT,
    has_played INTEGER AS Boolean NOT NULL DEFAULT 0,
    progress_seconds INTEGER NOT NULL DEFAULT 0,
    is_bookmarked INTEGER AS Boolean NOT NULL DEFAULT 0,
    is_archived INTEGER AS Boolean NOT NULL DEFAULT 0,

  FOREIGN KEY (channel_id)
    REFERENCES podcast(id)
    ON DELETE CASCADE
);

upsert {
  UPDATE episode
  SET id = :id,
      channel_id = :channel_id,
      channel_title = :channel_title,
      title = :title,
      description = :description,
      date = :date,
      link = :link,
      streaming_link = :streaming_link,
      image_url = :image_url,
      duration = :duration
  WHERE id = :id;

  INSERT OR IGNORE INTO episode (id, channel_id, channel_title, title, description, date, link, streaming_link, image_url, duration)
  VALUES (:id, :channel_id, :channel_title, :title, :description, :date, :link, :streaming_link, :image_url, :duration);
}

-- upsert:
-- INSERT OR REPLACE INTO episode (id, channel_id, channel_title, title, description, date, link, streaming_link, image_url, duration)
-- VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

get_all:
SELECT * FROM episode;

get_all_not_archived:
SELECT * FROM episode WHERE is_archived = 0;

get_by_id:
SELECT * FROM episode WHERE id = :id;

get_by_channel_id:
SELECT * FROM episode WHERE channel_id = :channelId;

get_bookmarked:
SELECT * FROM episode WHERE is_bookmarked = 1;

search_titles:
SELECT * FROM episode WHERE title LIKE (:term || '%');

delete_all:
DELETE FROM episode;
