import kotlin.Boolean;

CREATE TABLE episode (
    id TEXT PRIMARY KEY NOT NULL,
    channel_id TEXT NOT NULL
        REFERENCES podcast(id)
            ON DELETE CASCADE
            ON UPDATE CASCADE,
    channel_title TEXT NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    date INTEGER NOT NULL,
    link TEXT NOT NULL,
    streaming_link TEXT NOT NULL,
    image_url TEXT,
    duration TEXT,
    has_played INTEGER AS Boolean NOT NULL DEFAULT 0,
    progress_seconds INTEGER NOT NULL DEFAULT 0,
    is_bookmarked INTEGER AS Boolean NOT NULL DEFAULT 0,
    is_archived INTEGER AS Boolean NOT NULL DEFAULT 0
);

upsert {
  UPDATE episode
  SET id = :id,
      channel_id = :channel_id,
      channel_title = :channel_title,
      title = :title,
      description = :description,
      date = :date,
      link = :link,
      streaming_link = :streaming_link,
      image_url = :image_url,
      duration = :duration
  WHERE id = :id;

  INSERT OR IGNORE INTO episode (id, channel_id, channel_title, title, description, date, link, streaming_link, image_url, duration)
  VALUES (:id, :channel_id, :channel_title, :title, :description, :date, :link, :streaming_link, :image_url, :duration);
}

get_all:
SELECT * FROM episode
GROUP BY channel_id
ORDER BY date DESC;

get_all_not_archived:
SELECT * FROM episode
WHERE is_archived = 0
GROUP BY channel_id
ORDER BY date DESC;

get_by_id:
SELECT * FROM episode WHERE id = :id;

get_by_channel_id:
SELECT * FROM episode
WHERE channel_id = :channelId
ORDER BY date DESC;

-- Should we persist bookmarked_date and order by that?
get_bookmarked:
SELECT * FROM episode
WHERE is_bookmarked = 1
ORDER BY date DESC;

search_titles:
SELECT * FROM episode
WHERE title LIKE (:term || '%')
ORDER BY date DESC;

delete_all:
DELETE FROM episode;
